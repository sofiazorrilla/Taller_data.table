[
  {
    "objectID": "index.html#qué-ventajas-tiene",
    "href": "index.html#qué-ventajas-tiene",
    "title": "Introducción y recursos",
    "section": "¿Qué ventajas tiene?",
    "text": "¿Qué ventajas tiene?"
  },
  {
    "objectID": "index.html#instalación",
    "href": "index.html#instalación",
    "title": "Introducción y recursos",
    "section": "Instalación",
    "text": "Instalación\n\ninstall.packages(\"data.table\")"
  },
  {
    "objectID": "index.html#recursos",
    "href": "index.html#recursos",
    "title": "Introducción y recursos",
    "section": "Recursos",
    "text": "Recursos\n\nComunidad\n\nStackOverflow data.table\nWiki\nVignettes\nTutorial recomendado"
  },
  {
    "objectID": "tema3.html",
    "href": "tema3.html",
    "title": "Filtros y selección de columnas",
    "section": "",
    "text": "Similar a como se seleccionan filas en un data.frame, en un objeto data.table se pueden seleccionar filas utilizando rangos de índices. En los siguientes dos ejemplos se muestra como seleccionar las primeras dos filas de la tabla de registros.\nlibrary(data.table)\n\n\ndata = fread(\"data/plantae_mexico_conCoords_specimen.csv\")\n\ndata[1:2] \n\n       gbifID                 occurrenceID       phylum          class        order      family       genus\n        &lt;i64&gt;                       &lt;char&gt;       &lt;char&gt;         &lt;char&gt;       &lt;char&gt;      &lt;char&gt;      &lt;char&gt;\n1: 2825623524 TAIF:PLANT:318128:1:1:411555 Tracheophyta Polypodiopsida Polypodiales Pteridaceae    Adiantum\n2: 2825649445 TAIF:PLANT:318579:1:1:411579 Tracheophyta Polypodiopsida Polypodiales Pteridaceae Scoliosorus\n                  species infraspecificEpithet taxonRank                         scientificName\n                   &lt;char&gt;               &lt;char&gt;    &lt;char&gt;                                 &lt;char&gt;\n1:      Adiantum andicola                        SPECIES               Adiantum andicola Liebm.\n2: Scoliosorus ensiformis                        SPECIES Scoliosorus ensiformis (Hook.) T.Moore\n                    verbatimScientificName verbatimScientificNameAuthorship countryCode     stateProvince\n                                    &lt;char&gt;                           &lt;lgcl&gt;      &lt;char&gt;            &lt;char&gt;\n1:                Adiantum andicola Liebm.                               NA          MX Oaxaca (瓦哈卡州)\n2: Scoliosorus ensiformis (Hook.) T. Moore                               NA          MX Oaxaca (瓦哈卡州)\n   decimalLatitude decimalLongitude coordinateUncertaintyInMeters elevation   day month  year      basisOfRecord\n             &lt;num&gt;            &lt;num&gt;                        &lt;lgcl&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;             &lt;char&gt;\n1:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n2:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n\n\n\nNota: Cuando solo estamos seleccionando filas no es necesario incluir la coma al final.\n\ndata[1:2,] \n\n       gbifID                 occurrenceID       phylum          class        order      family       genus\n        &lt;i64&gt;                       &lt;char&gt;       &lt;char&gt;         &lt;char&gt;       &lt;char&gt;      &lt;char&gt;      &lt;char&gt;\n1: 2825623524 TAIF:PLANT:318128:1:1:411555 Tracheophyta Polypodiopsida Polypodiales Pteridaceae    Adiantum\n2: 2825649445 TAIF:PLANT:318579:1:1:411579 Tracheophyta Polypodiopsida Polypodiales Pteridaceae Scoliosorus\n                  species infraspecificEpithet taxonRank                         scientificName\n                   &lt;char&gt;               &lt;char&gt;    &lt;char&gt;                                 &lt;char&gt;\n1:      Adiantum andicola                        SPECIES               Adiantum andicola Liebm.\n2: Scoliosorus ensiformis                        SPECIES Scoliosorus ensiformis (Hook.) T.Moore\n                    verbatimScientificName verbatimScientificNameAuthorship countryCode     stateProvince\n                                    &lt;char&gt;                           &lt;lgcl&gt;      &lt;char&gt;            &lt;char&gt;\n1:                Adiantum andicola Liebm.                               NA          MX Oaxaca (瓦哈卡州)\n2: Scoliosorus ensiformis (Hook.) T. Moore                               NA          MX Oaxaca (瓦哈卡州)\n   decimalLatitude decimalLongitude coordinateUncertaintyInMeters elevation   day month  year      basisOfRecord\n             &lt;num&gt;            &lt;num&gt;                        &lt;lgcl&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;             &lt;char&gt;\n1:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n2:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n\n\n\n\n\n\nDe acuerdo con la sintaxis del paquete, el espacio i es el lugar en el que se pueden realizar operaciones sobre las filas como los filtros. Por ejemplo, utilizando la tabla de registros de especies de plantas podríamos estar interesados en solo seleccionar aquellos registros que pertenezcan al género Quercus.\ndata_quercus &lt;- data[genus == \"Quercus\",] \n\ndim(data_quercus)\n\n\n[1] 51985    23\n\n\nO podríamos estar interesadas en seleccionar solo los registros más viejos, los que fueron colectados antes de 1950.\ndata_quercus_viejos &lt;- data[genus == \"Quercus\" & year &lt;= 1950,]\n\ndim(data_quercus_viejos)\n\n\n[1] 2927   23\n\n\n\n\n\n\nOtra función que se puede realizar en el espacio de las filas es ordenarlas. Por ejemplo, podríamos ordenar la tabla de registros del género Quercus por estado en orden alfabético.\n\n# Ordenar los datos de la tabla de registros de Quercus por estado en orden alfabetico\n\nordered_data = data_quercus[order(stateProvince)]\n\n# seleccionar la columna de estado como vector y seleccionar los valores únicos\n# mostrar solo los primeros valores\n\nunique(ordered_data$stateProvince) |&gt; head()\n\n[1] \"\"                        \"Aguascalientes\"          \"Baja California\"         \"Baja California (norte)\"\n[5] \"Baja California Norte\"   \"Baja California Sur\"    \n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\n\nCarga el archivo de registros de plantas utilizando la función fread que revisamos en el tema anterior\nUtiliza un filtro para quedarte con las filas que pertenezcan a un género o especie que te guste\nOrdena de manera descendente por año\n\nPregunta:\n¿De qué año son los registros más nuevos y más viejos de la especie que escogiste? (selecciona utilizando rangos la primera y la última fila de la tabla)\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\nlibrary(data.table)\n\ndata = fread(\"data/plantae_mexico_conCoords_specimen.csv\", quote=\"\")\n\ndata_quercus &lt;- data[genus == \"Quercus\" & !is.na(year),] \n\ndata_quercus_ordenado &lt;- data_quercus[order(-year)] \n\n# Una función útil en el paquete es la función .N que te permite guardar el número de observaciones en el grupo actual. En este caso solo tenemos un solo grupo y por lo tanto guarda el número de filas en la tabla.\n\ndata_quercus_ordenado[c(1, nrow(data_quercus_ordenado)),]$year\n\n\n[1] 2023 1827"
  },
  {
    "objectID": "tema3.html#seleccionar-por-índices",
    "href": "tema3.html#seleccionar-por-índices",
    "title": "Filtros y selección de columnas",
    "section": "",
    "text": "Similar a como se seleccionan filas en un data.frame, en un objeto data.table se pueden seleccionar filas utilizando rangos de índices. En los siguientes dos ejemplos se muestra como seleccionar las primeras dos filas de la tabla de registros.\nlibrary(data.table)\n\n\ndata = fread(\"data/plantae_mexico_conCoords_specimen.csv\")\n\ndata[1:2] \n\n       gbifID                 occurrenceID       phylum          class        order      family       genus\n        &lt;i64&gt;                       &lt;char&gt;       &lt;char&gt;         &lt;char&gt;       &lt;char&gt;      &lt;char&gt;      &lt;char&gt;\n1: 2825623524 TAIF:PLANT:318128:1:1:411555 Tracheophyta Polypodiopsida Polypodiales Pteridaceae    Adiantum\n2: 2825649445 TAIF:PLANT:318579:1:1:411579 Tracheophyta Polypodiopsida Polypodiales Pteridaceae Scoliosorus\n                  species infraspecificEpithet taxonRank                         scientificName\n                   &lt;char&gt;               &lt;char&gt;    &lt;char&gt;                                 &lt;char&gt;\n1:      Adiantum andicola                        SPECIES               Adiantum andicola Liebm.\n2: Scoliosorus ensiformis                        SPECIES Scoliosorus ensiformis (Hook.) T.Moore\n                    verbatimScientificName verbatimScientificNameAuthorship countryCode     stateProvince\n                                    &lt;char&gt;                           &lt;lgcl&gt;      &lt;char&gt;            &lt;char&gt;\n1:                Adiantum andicola Liebm.                               NA          MX Oaxaca (瓦哈卡州)\n2: Scoliosorus ensiformis (Hook.) T. Moore                               NA          MX Oaxaca (瓦哈卡州)\n   decimalLatitude decimalLongitude coordinateUncertaintyInMeters elevation   day month  year      basisOfRecord\n             &lt;num&gt;            &lt;num&gt;                        &lt;lgcl&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;             &lt;char&gt;\n1:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n2:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n\n\n\nNota: Cuando solo estamos seleccionando filas no es necesario incluir la coma al final.\n\ndata[1:2,] \n\n       gbifID                 occurrenceID       phylum          class        order      family       genus\n        &lt;i64&gt;                       &lt;char&gt;       &lt;char&gt;         &lt;char&gt;       &lt;char&gt;      &lt;char&gt;      &lt;char&gt;\n1: 2825623524 TAIF:PLANT:318128:1:1:411555 Tracheophyta Polypodiopsida Polypodiales Pteridaceae    Adiantum\n2: 2825649445 TAIF:PLANT:318579:1:1:411579 Tracheophyta Polypodiopsida Polypodiales Pteridaceae Scoliosorus\n                  species infraspecificEpithet taxonRank                         scientificName\n                   &lt;char&gt;               &lt;char&gt;    &lt;char&gt;                                 &lt;char&gt;\n1:      Adiantum andicola                        SPECIES               Adiantum andicola Liebm.\n2: Scoliosorus ensiformis                        SPECIES Scoliosorus ensiformis (Hook.) T.Moore\n                    verbatimScientificName verbatimScientificNameAuthorship countryCode     stateProvince\n                                    &lt;char&gt;                           &lt;lgcl&gt;      &lt;char&gt;            &lt;char&gt;\n1:                Adiantum andicola Liebm.                               NA          MX Oaxaca (瓦哈卡州)\n2: Scoliosorus ensiformis (Hook.) T. Moore                               NA          MX Oaxaca (瓦哈卡州)\n   decimalLatitude decimalLongitude coordinateUncertaintyInMeters elevation   day month  year      basisOfRecord\n             &lt;num&gt;            &lt;num&gt;                        &lt;lgcl&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;             &lt;char&gt;\n1:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN\n2:        17.30213         -96.3808                            NA      2267    27     2  2012 PRESERVED_SPECIMEN"
  },
  {
    "objectID": "tema3.html#filtrar-filas",
    "href": "tema3.html#filtrar-filas",
    "title": "Filtros y selección de columnas",
    "section": "",
    "text": "De acuerdo con la sintaxis del paquete, el espacio i es el lugar en el que se pueden realizar operaciones sobre las filas como los filtros. Por ejemplo, utilizando la tabla de registros de especies de plantas podríamos estar interesados en solo seleccionar aquellos registros que pertenezcan al género Quercus.\ndata_quercus &lt;- data[genus == \"Quercus\",] \n\ndim(data_quercus)\n\n\n[1] 51985    23\n\n\nO podríamos estar interesadas en seleccionar solo los registros más viejos, los que fueron colectados antes de 1950.\ndata_quercus_viejos &lt;- data[genus == \"Quercus\" & year &lt;= 1950,]\n\ndim(data_quercus_viejos)\n\n\n[1] 2927   23"
  },
  {
    "objectID": "tema3.html#ordenar-filas",
    "href": "tema3.html#ordenar-filas",
    "title": "Filtros y selección de columnas",
    "section": "",
    "text": "Otra función que se puede realizar en el espacio de las filas es ordenarlas. Por ejemplo, podríamos ordenar la tabla de registros del género Quercus por estado en orden alfabético.\n\n# Ordenar los datos de la tabla de registros de Quercus por estado en orden alfabetico\n\nordered_data = data_quercus[order(stateProvince)]\n\n# seleccionar la columna de estado como vector y seleccionar los valores únicos\n# mostrar solo los primeros valores\n\nunique(ordered_data$stateProvince) |&gt; head()\n\n[1] \"\"                        \"Aguascalientes\"          \"Baja California\"         \"Baja California (norte)\"\n[5] \"Baja California Norte\"   \"Baja California Sur\"    \n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\n\nCarga el archivo de registros de plantas utilizando la función fread que revisamos en el tema anterior\nUtiliza un filtro para quedarte con las filas que pertenezcan a un género o especie que te guste\nOrdena de manera descendente por año\n\nPregunta:\n¿De qué año son los registros más nuevos y más viejos de la especie que escogiste? (selecciona utilizando rangos la primera y la última fila de la tabla)\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\nlibrary(data.table)\n\ndata = fread(\"data/plantae_mexico_conCoords_specimen.csv\", quote=\"\")\n\ndata_quercus &lt;- data[genus == \"Quercus\" & !is.na(year),] \n\ndata_quercus_ordenado &lt;- data_quercus[order(-year)] \n\n# Una función útil en el paquete es la función .N que te permite guardar el número de observaciones en el grupo actual. En este caso solo tenemos un solo grupo y por lo tanto guarda el número de filas en la tabla.\n\ndata_quercus_ordenado[c(1, nrow(data_quercus_ordenado)),]$year\n\n\n[1] 2023 1827"
  },
  {
    "objectID": "tema3.html#seleccionar-columnas-por-índice",
    "href": "tema3.html#seleccionar-columnas-por-índice",
    "title": "Filtros y selección de columnas",
    "section": "Seleccionar columnas por índice",
    "text": "Seleccionar columnas por índice\nDe acuerdo con la sintaxis del paquete, el espacio j nos permite realizar operaciones sobre las columnas. Una de esas operaciones es la selección de columnas.\nSe pueden seleccionar por medio de índices:\n\ndata[,7:8,]\n\n               genus               species\n              &lt;char&gt;                &lt;char&gt;\n     1:    Syngonium  Syngonium angustatum\n     2:     Scaevola     Scaevola plumieri\n     3:   Tillandsia    Tillandsia fuchsii\n     4:    Commelina     Commelina rufipes\n     5: Heterosperma Heterosperma pinnatum\n    ---                                   \n 99996:   Polypodium                      \n 99997: Hesperoyucca Hesperoyucca whipplei\n 99998: Fimbristylis   Fimbristylis cymosa\n 99999:    Commelina    Commelina tuberosa\n100000:       Salvia    Salvia polystachia"
  },
  {
    "objectID": "tema3.html#seleccionar-columnas-por-nombre",
    "href": "tema3.html#seleccionar-columnas-por-nombre",
    "title": "Filtros y selección de columnas",
    "section": "Seleccionar columnas por nombre",
    "text": "Seleccionar columnas por nombre\nSe pueden seleccionar las columas por nombre y regresar como vector:\n\ndata[,species] |&gt; head()\n\n[1] \"Syngonium angustatum\"  \"Scaevola plumieri\"     \"Tillandsia fuchsii\"    \"Commelina rufipes\"    \n[5] \"Heterosperma pinnatum\" \"Begonia crassicaulis\" \n\n\nSe pueden seleccionar las columnas usando una lista y regresar como tabla:\n\ndata[,list(family,genus,species)]\n\n               family        genus               species\n               &lt;char&gt;       &lt;char&gt;                &lt;char&gt;\n     1:       Araceae    Syngonium  Syngonium angustatum\n     2:  Goodeniaceae     Scaevola     Scaevola plumieri\n     3:  Bromeliaceae   Tillandsia    Tillandsia fuchsii\n     4: Commelinaceae    Commelina     Commelina rufipes\n     5:    Asteraceae Heterosperma Heterosperma pinnatum\n    ---                                                 \n 99996: Polypodiaceae   Polypodium                      \n 99997:  Asparagaceae Hesperoyucca Hesperoyucca whipplei\n 99998:    Cyperaceae Fimbristylis   Fimbristylis cymosa\n 99999: Commelinaceae    Commelina    Commelina tuberosa\n100000:     Lamiaceae       Salvia    Salvia polystachia\n\n\nUn atajo para no escribir list() es .():\n\ndata[,.(family,genus,species)]\n\n               family        genus               species\n               &lt;char&gt;       &lt;char&gt;                &lt;char&gt;\n     1:       Araceae    Syngonium  Syngonium angustatum\n     2:  Goodeniaceae     Scaevola     Scaevola plumieri\n     3:  Bromeliaceae   Tillandsia    Tillandsia fuchsii\n     4: Commelinaceae    Commelina     Commelina rufipes\n     5:    Asteraceae Heterosperma Heterosperma pinnatum\n    ---                                                 \n 99996: Polypodiaceae   Polypodium                      \n 99997:  Asparagaceae Hesperoyucca Hesperoyucca whipplei\n 99998:    Cyperaceae Fimbristylis   Fimbristylis cymosa\n 99999: Commelinaceae    Commelina    Commelina tuberosa\n100000:     Lamiaceae       Salvia    Salvia polystachia\n\n\nPara seleccionar columnas guardadas en una variable se puede utilizar el prefijo ..:\n\nvariables &lt;- c(\"family\",\"genus\",\"species\")\n\ndata[ , ..variables]\n\n               family        genus               species\n               &lt;char&gt;       &lt;char&gt;                &lt;char&gt;\n     1:       Araceae    Syngonium  Syngonium angustatum\n     2:  Goodeniaceae     Scaevola     Scaevola plumieri\n     3:  Bromeliaceae   Tillandsia    Tillandsia fuchsii\n     4: Commelinaceae    Commelina     Commelina rufipes\n     5:    Asteraceae Heterosperma Heterosperma pinnatum\n    ---                                                 \n 99996: Polypodiaceae   Polypodium                      \n 99997:  Asparagaceae Hesperoyucca Hesperoyucca whipplei\n 99998:    Cyperaceae Fimbristylis   Fimbristylis cymosa\n 99999: Commelinaceae    Commelina    Commelina tuberosa\n100000:     Lamiaceae       Salvia    Salvia polystachia\n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\n\nSelecciona las columnas que contengan información acerca de la ubicación geográfica de los registros.\n\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\ninfo_geografica &lt;- c(“countryCode”, “stateProvince”, “decimalLatitude”, “decimalLongitude”, “coordinateUncertaintyInMeters”, “elevation”)\n\nvars_info_geografica &lt;- c(\"countryCode\", \"stateProvince\", \"decimalLatitude\", \"decimalLongitude\", \"coordinateUncertaintyInMeters\", \"elevation\")\n\ndata[,..vars_info_geografica,]\n\n        countryCode                   stateProvince decimalLatitude decimalLongitude coordinateUncertaintyInMeters\n             &lt;char&gt;                          &lt;char&gt;           &lt;num&gt;            &lt;num&gt;                         &lt;num&gt;\n     1:          MX                        Veracruz        19.33330        -96.66670                            NA\n     2:          MX                         Yucatan        21.25417        -89.80833                            70\n     3:          MX                         Chiapas        15.65000        -92.80000                           100\n     4:          MX                         Chiapas        16.08111        -93.47805                           100\n     5:          MX                         Durango        25.54389       -104.59100                            50\n    ---                                                                                                           \n 99996:          MX                          Mexico        20.00583       -100.13200                            80\n 99997:          MX                 Baja California        32.35806       -116.93146                         10000\n 99998:          MX Veracruz de ignacio de la llave        20.20833        -96.79167                            80\n 99999:          MX             Michoacan de ocampo        19.76222       -100.86611                            80\n100000:          MX                        Guerrero        17.46814       -100.13643                         10490\n        elevation\n            &lt;num&gt;\n     1:        NA\n     2:       0.0\n     3:    1400.0\n     4:     473.5\n     5:    1900.0\n    ---          \n 99996:    2400.0\n 99997:        NA\n 99998:        NA\n 99999:    1020.0\n100000:    1300.0"
  },
  {
    "objectID": "tema3.html#renombrar-columnas",
    "href": "tema3.html#renombrar-columnas",
    "title": "Filtros y selección de columnas",
    "section": "Renombrar columnas",
    "text": "Renombrar columnas\nEn el espacio de operaciones sobre las columnas también se pueden renombrar las columnas.\n\ndata[, .(especie = species, genero = genus)]\n\n                      especie       genero\n                       &lt;char&gt;       &lt;char&gt;\n     1:  Syngonium angustatum    Syngonium\n     2:     Scaevola plumieri     Scaevola\n     3:    Tillandsia fuchsii   Tillandsia\n     4:     Commelina rufipes    Commelina\n     5: Heterosperma pinnatum Heterosperma\n    ---                                   \n 99996:                         Polypodium\n 99997: Hesperoyucca whipplei Hesperoyucca\n 99998:   Fimbristylis cymosa Fimbristylis\n 99999:    Commelina tuberosa    Commelina\n100000:    Salvia polystachia       Salvia"
  },
  {
    "objectID": "tema7.html",
    "href": "tema7.html",
    "title": "Uniones entre tablas",
    "section": "",
    "text": "Hay dos formas de escribir uniones entre tablas usando data.table. La primera es mediante la función merge() de r base. Los argumentos básicos de esta función son:\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\nx, y = son los objetos data.table que se quieren unir\nby, by.x, by.y = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\nall, all.x, all.y = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\n\n       id letter1\n    &lt;int&gt;  &lt;char&gt;\n 1:     1       H\n 2:     2       C\n 3:     3       H\n 4:     4       D\n 5:     5       D\n 6:     6       D\n 7:     7       J\n 8:     8       H\n 9:     9       I\n10:    10       I\n\ndt2\n\n       id letter2\n    &lt;int&gt;  &lt;char&gt;\n 1:     6       A\n 2:     7       A\n 3:     8       B\n 4:     9       B\n 5:    10       D\n 6:    11       A\n 7:    12       I\n 8:    13       I\n 9:    14       F\n10:    15       J\n\n# inner join\nmerge(dt1,dt2,by = \"id\")\n\nKey: &lt;id&gt;\n      id letter1 letter2\n   &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n1:     6       D       A\n2:     7       J       A\n3:     8       H       B\n4:     9       I       B\n5:    10       I       D\n\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n\nKey: &lt;id&gt;\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     1       H    &lt;NA&gt;\n 2:     2       C    &lt;NA&gt;\n 3:     3       H    &lt;NA&gt;\n 4:     4       D    &lt;NA&gt;\n 5:     5       D    &lt;NA&gt;\n 6:     6       D       A\n 7:     7       J       A\n 8:     8       H       B\n 9:     9       I       B\n10:    10       I       D\n\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n\nKey: &lt;id&gt;\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     6       D       A\n 2:     7       J       A\n 3:     8       H       B\n 4:     9       I       B\n 5:    10       I       D\n 6:    11    &lt;NA&gt;       A\n 7:    12    &lt;NA&gt;       I\n 8:    13    &lt;NA&gt;       I\n 9:    14    &lt;NA&gt;       F\n10:    15    &lt;NA&gt;       J\n\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n\nKey: &lt;id&gt;\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     1       H    &lt;NA&gt;\n 2:     2       C    &lt;NA&gt;\n 3:     3       H    &lt;NA&gt;\n 4:     4       D    &lt;NA&gt;\n 5:     5       D    &lt;NA&gt;\n 6:     6       D       A\n 7:     7       J       A\n 8:     8       H       B\n 9:     9       I       B\n10:    10       I       D\n11:    11    &lt;NA&gt;       A\n12:    12    &lt;NA&gt;       I\n13:    13    &lt;NA&gt;       I\n14:    14    &lt;NA&gt;       F\n15:    15    &lt;NA&gt;       J"
  },
  {
    "objectID": "tema7.html#función-merge",
    "href": "tema7.html#función-merge",
    "title": "Uniones entre tablas",
    "section": "",
    "text": "Hay dos formas de escribir uniones entre tablas usando data.table. La primera es mediante la función merge() de r base. Los argumentos básicos de esta función son:\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\nx, y = son los objetos data.table que se quieren unir\nby, by.x, by.y = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\nall, all.x, all.y = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\n\n       id letter1\n    &lt;int&gt;  &lt;char&gt;\n 1:     1       H\n 2:     2       C\n 3:     3       H\n 4:     4       D\n 5:     5       D\n 6:     6       D\n 7:     7       J\n 8:     8       H\n 9:     9       I\n10:    10       I\n\ndt2\n\n       id letter2\n    &lt;int&gt;  &lt;char&gt;\n 1:     6       A\n 2:     7       A\n 3:     8       B\n 4:     9       B\n 5:    10       D\n 6:    11       A\n 7:    12       I\n 8:    13       I\n 9:    14       F\n10:    15       J\n\n# inner join\nmerge(dt1,dt2,by = \"id\")\n\nKey: &lt;id&gt;\n      id letter1 letter2\n   &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n1:     6       D       A\n2:     7       J       A\n3:     8       H       B\n4:     9       I       B\n5:    10       I       D\n\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n\nKey: &lt;id&gt;\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     1       H    &lt;NA&gt;\n 2:     2       C    &lt;NA&gt;\n 3:     3       H    &lt;NA&gt;\n 4:     4       D    &lt;NA&gt;\n 5:     5       D    &lt;NA&gt;\n 6:     6       D       A\n 7:     7       J       A\n 8:     8       H       B\n 9:     9       I       B\n10:    10       I       D\n\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n\nKey: &lt;id&gt;\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     6       D       A\n 2:     7       J       A\n 3:     8       H       B\n 4:     9       I       B\n 5:    10       I       D\n 6:    11    &lt;NA&gt;       A\n 7:    12    &lt;NA&gt;       I\n 8:    13    &lt;NA&gt;       I\n 9:    14    &lt;NA&gt;       F\n10:    15    &lt;NA&gt;       J\n\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n\nKey: &lt;id&gt;\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     1       H    &lt;NA&gt;\n 2:     2       C    &lt;NA&gt;\n 3:     3       H    &lt;NA&gt;\n 4:     4       D    &lt;NA&gt;\n 5:     5       D    &lt;NA&gt;\n 6:     6       D       A\n 7:     7       J       A\n 8:     8       H       B\n 9:     9       I       B\n10:    10       I       D\n11:    11    &lt;NA&gt;       A\n12:    12    &lt;NA&gt;       I\n13:    13    &lt;NA&gt;       I\n14:    14    &lt;NA&gt;       F\n15:    15    &lt;NA&gt;       J"
  },
  {
    "objectID": "tema7.html#sintaxis-de-data.table",
    "href": "tema7.html#sintaxis-de-data.table",
    "title": "Uniones entre tablas",
    "section": "Sintaxis de data.table",
    "text": "Sintaxis de data.table\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table.\nDT1[DT2, nomatch = 0]\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es x, la tabla que está por dentro es y y el argumento nomatch te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando nomatch = 0 no incluye las claves que no se comparten entre tablas.\n\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n\n      id letter1 letter2\n   &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n1:     6       D       A\n2:     7       J       A\n3:     8       H       B\n4:     9       I       B\n5:    10       I       D\n\n# left join\ndt1[dt2, on = \"id\"]\n\n       id letter1 letter2\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     6       D       A\n 2:     7       J       A\n 3:     8       H       B\n 4:     9       I       B\n 5:    10       I       D\n 6:    11    &lt;NA&gt;       A\n 7:    12    &lt;NA&gt;       I\n 8:    13    &lt;NA&gt;       I\n 9:    14    &lt;NA&gt;       F\n10:    15    &lt;NA&gt;       J\n\n# right join\ndt2[dt1, on = \"id\"]\n\n       id letter2 letter1\n    &lt;int&gt;  &lt;char&gt;  &lt;char&gt;\n 1:     1    &lt;NA&gt;       H\n 2:     2    &lt;NA&gt;       C\n 3:     3    &lt;NA&gt;       H\n 4:     4    &lt;NA&gt;       D\n 5:     5    &lt;NA&gt;       D\n 6:     6       A       D\n 7:     7       A       J\n 8:     8       B       H\n 9:     9       B       I\n10:    10       D       I"
  },
  {
    "objectID": "tema7.html#ejercicio",
    "href": "tema7.html#ejercicio",
    "title": "Uniones entre tablas",
    "section": "Ejercicio",
    "text": "Ejercicio\nQueremos averiguar cuántos registros y de cuántas especies de algún género de plantas hay de cada categoría de conservación (IUCN) para México.\nCon lo aprendido en los temas anteriores podemos generar un subconjunto de la tabla de registros que solo tenga los registros de un género (por ejemplo para el género Quercus).\nPaso 1. Filtra la tabla de registros de plantas para México para quedarte con la información de algún género que te guste.\nAdemás, encontramos que utilizando el paquete rredlist podemos buscar el estatus de conservación de la IUCN para algunas especies que nos interesen con la función rl_search.\nEl siguiente código muestra una forma para obtener el estatus de conservación. Lo que hace es buscar los resultados en la base de datos de la lista roja para cada especie en el subconjunto de registros de encinos de la tabla de registros de plantas para México.\n\nlibrary(\"rredlist\")\nlibrary(\"magrittr\")\n\ndata = fread(\"data/data_quercus.csv\")\n\ntoken = \"9bb4facb6d23f48efbf424bb05c0c1ef1cf6f468393bc745d42179ac4aca5fee\"\n\nsp_list = unique(data$species)\nsp_list = sp_list[which(sp_list != \"\")] # quitar elementos vacios\n\nred_list = list()\n\nfor (i in sp_list) {\n        red_list[[i]] &lt;- rl_search(i, key = token)$result\n}\n\n# seleccionar columnas útiles\niucn_data = do.call(rbind,red_list) %&gt;% select(scientific_name, category, population_trend)\n\nwrite.csv(iucn_data, \"data/iucn_data.csv\", row.names = F)\n\nPaso 2: Utiliza el código anterior para generar la tabla de estados de conservación para las especies del género que elegiste.\nPaso 3: Une la tabla de los registros del genero que escogiste con la de estados de conservación\nPaso 4: Haz un resumen del número de registros y el número de especies que hay para cada estado de conservación. Por ejemplo, para los encinos los resultados son los siguientes:\n\n\n\n\n\ncategory\nnumero_registros\nnumero_sp\n\n\n\n\nEN\n996\n19\n\n\nLC\n41064\n96\n\n\nNT\n3214\n18\n\n\nVU\n1876\n9\n\n\nDD\n762\n21\n\n\nCR\n8\n1\n\n\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n#| echo: false\n\ndata = fread(\"data/data_quercus.csv\")\n\ndataIUCN = fread(\"data/iucn_data.csv\")\nsetnames(dataIUCN, \"scientific_name\", \"species\") # renombrar la columna de scientific_name a species porque es la clave que ambas tablas tienen en comun\n\n# Hacer un left join para añadir la información de la iucn a la tabla de datos\njoin = data[dataIUCN, on = \"species\"]\n\n# Hacer el resumen, primero contando los registros agrupando por especie y por categoría. Después, utilizando una cadena y solo agrupamos por categoría, la suma de las filas dentro de un grupo sería el número de registros que pertenecen a la categoría y el número de filas de cada grupo corresponde al número de especies en la categoría.\n\njoin[,.N,by=.(species,category)][,.(numero_registros = sum(N),numero_sp = .N),by = category]"
  },
  {
    "objectID": "tema2.html",
    "href": "tema2.html",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "Un objeto data.table se puede definir, por ejemplo:\n\nlibrary(data.table)\n\nDT = data.table(\n  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n  a = 1:6,\n  b = 7:12,\n  c = 13:18\n)\n\nDT\n\n       ID     a     b     c\n   &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1:      b     1     7    13\n2:      b     2     8    14\n3:      b     3     9    15\n4:      a     4    10    16\n5:      a     5    11    17\n6:      c     6    12    18\n\n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\nImaginemos que queremos crear una simulación de una base de datos de secuencias aleatorias. La tabla que queremos al final va a tener dos columnas, la primera es un número identificador de cada secuencia y la segunda la secuencia aleatoria de tamaño 300. Por ejemplo, la siguiente tabla muestra las primeras 10 filas del resultado esperado.\n\n\n\n\n\n\n\n\n\nid\nsequencia\n\n\n\n\n1\nGCTCAGTCAACGACTAACCGCTCATAGGGAGGGGTCGAAATTAACCCCGCACACAGCCTTGGATAAGGGTCCAAGTCACGCAAGTTATATATAGTGACTG\n\n\n2\nTAACTCACAAGTTCTAATTCTCAATTGTTGGCCTTTTCAACGCATCTCCGATCGCGGTTTTGACTAAGACCAGCCGTTACCGTTGGTTATAGGGTCTCCC\n\n\n3\nTAAGACGGGGTATCTACATGATGTCCTTAAGTCCCATACCGCCCCCCCGCGAGTTGTCATTTAGAAAAGGTCAGTCATGCGTATCATTGGCATCCCCTAT\n\n\n4\nATTTCACGTCGACGCTCCTTCTACAACGTCTGTCAGATCGCACGAATGCCGAGAAGGAGGAAGTATGGAGCGGTTTTGCGCCACATCCCTAATCCGCAGA\n\n\n5\nCAGCGAGGTGCTCTCACGGATACCCGGAGGAAAGCGGTGAAAAACTCTCGTACCTGCCCATTTCATCTTGACCGTACCCGTGACGGCGAATCAAAACGAG\n\n\n6\nGGTAGCTCCAAAAATTTCGTTAAGACATAGCAGCCTTATTACCCATGCCCGAAATTCGTTCAGTGTAGGGCACGTCCCACATGAGCGATCCGTGTAGTTT\n\n\n\n\n\nEjercicio: Genera un objeto data.table en el que la primera columna sea un id de secuencia y la segunda sea una secuencia (aleatoria) de tamaño 300 caracteres\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n\nsecuencias &lt;- data.table(\n                id = seq(1,10000), \n                sequencia = sapply(seq(1, 10000), function(x) paste(sample(c(\"A\", \"T\", \"C\", \"G\"), 100, replace = TRUE), collapse = \"\")))\n\nhead(secuencias)\n\n      id                                                                                            sequencia\n   &lt;int&gt;                                                                                               &lt;char&gt;\n1:     1 TTCGGGGTGTATGAAACCCTGCTTAGTTTCGTTAGTCGCTTGGTCCCCCCTAGCTCAACATGGTTGGATTGAGCTCAGTTCAGGATCGGCATACAATAAC\n2:     2 GATCAAGGATCCTGCTTGACTGTTTGAACTTTACTAGGATGTGCTTTTGGGTCTGGCACTACTGCAGGGTCGACCGGACCCCCACCTCGTAGAGTGTGAT\n3:     3 ATTCGGTAGCAGTGATAGAGACGATTAGCCAGGATAGCCCGTGACATCTTACGTTCTTACAACACGTGTAAAGCCCTAGCGTTACCAAAGGAATAACCGA\n4:     4 GCTGGGCACCCAGAATCGTTCTCGTGAATATGCACGCAGCACATCGAGCAACGACACCACCCGCCGTAGACCAATTACGACGGACGATAGAGAGCACGAT\n5:     5 TTTTCTGCTAATTGGACAGCTCAACAATGCAAATACCACGCACGTCCTAAATTTCGCGAACGCTCAACGGACGTACAAGTCGCCATGTGAGCTGGCAGTT\n6:     6 GCTACGATAATCTATTTTCCGTACATAGGCTGGACAAATCGGTACTCGCTGACTACTTGCTTACTATCCAGGCATCCAACATGGAATCGATTAATAGAGA"
  },
  {
    "objectID": "tema2.html#crear-un-objeto-data.table",
    "href": "tema2.html#crear-un-objeto-data.table",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "Un objeto data.table se puede definir, por ejemplo:\n\nlibrary(data.table)\n\nDT = data.table(\n  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n  a = 1:6,\n  b = 7:12,\n  c = 13:18\n)\n\nDT\n\n       ID     a     b     c\n   &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1:      b     1     7    13\n2:      b     2     8    14\n3:      b     3     9    15\n4:      a     4    10    16\n5:      a     5    11    17\n6:      c     6    12    18\n\n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\nImaginemos que queremos crear una simulación de una base de datos de secuencias aleatorias. La tabla que queremos al final va a tener dos columnas, la primera es un número identificador de cada secuencia y la segunda la secuencia aleatoria de tamaño 300. Por ejemplo, la siguiente tabla muestra las primeras 10 filas del resultado esperado.\n\n\n\n\n\n\n\n\n\nid\nsequencia\n\n\n\n\n1\nGCTCAGTCAACGACTAACCGCTCATAGGGAGGGGTCGAAATTAACCCCGCACACAGCCTTGGATAAGGGTCCAAGTCACGCAAGTTATATATAGTGACTG\n\n\n2\nTAACTCACAAGTTCTAATTCTCAATTGTTGGCCTTTTCAACGCATCTCCGATCGCGGTTTTGACTAAGACCAGCCGTTACCGTTGGTTATAGGGTCTCCC\n\n\n3\nTAAGACGGGGTATCTACATGATGTCCTTAAGTCCCATACCGCCCCCCCGCGAGTTGTCATTTAGAAAAGGTCAGTCATGCGTATCATTGGCATCCCCTAT\n\n\n4\nATTTCACGTCGACGCTCCTTCTACAACGTCTGTCAGATCGCACGAATGCCGAGAAGGAGGAAGTATGGAGCGGTTTTGCGCCACATCCCTAATCCGCAGA\n\n\n5\nCAGCGAGGTGCTCTCACGGATACCCGGAGGAAAGCGGTGAAAAACTCTCGTACCTGCCCATTTCATCTTGACCGTACCCGTGACGGCGAATCAAAACGAG\n\n\n6\nGGTAGCTCCAAAAATTTCGTTAAGACATAGCAGCCTTATTACCCATGCCCGAAATTCGTTCAGTGTAGGGCACGTCCCACATGAGCGATCCGTGTAGTTT\n\n\n\n\n\nEjercicio: Genera un objeto data.table en el que la primera columna sea un id de secuencia y la segunda sea una secuencia (aleatoria) de tamaño 300 caracteres\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n\nsecuencias &lt;- data.table(\n                id = seq(1,10000), \n                sequencia = sapply(seq(1, 10000), function(x) paste(sample(c(\"A\", \"T\", \"C\", \"G\"), 100, replace = TRUE), collapse = \"\")))\n\nhead(secuencias)\n\n      id                                                                                            sequencia\n   &lt;int&gt;                                                                                               &lt;char&gt;\n1:     1 TTCGGGGTGTATGAAACCCTGCTTAGTTTCGTTAGTCGCTTGGTCCCCCCTAGCTCAACATGGTTGGATTGAGCTCAGTTCAGGATCGGCATACAATAAC\n2:     2 GATCAAGGATCCTGCTTGACTGTTTGAACTTTACTAGGATGTGCTTTTGGGTCTGGCACTACTGCAGGGTCGACCGGACCCCCACCTCGTAGAGTGTGAT\n3:     3 ATTCGGTAGCAGTGATAGAGACGATTAGCCAGGATAGCCCGTGACATCTTACGTTCTTACAACACGTGTAAAGCCCTAGCGTTACCAAAGGAATAACCGA\n4:     4 GCTGGGCACCCAGAATCGTTCTCGTGAATATGCACGCAGCACATCGAGCAACGACACCACCCGCCGTAGACCAATTACGACGGACGATAGAGAGCACGAT\n5:     5 TTTTCTGCTAATTGGACAGCTCAACAATGCAAATACCACGCACGTCCTAAATTTCGCGAACGCTCAACGGACGTACAAGTCGCCATGTGAGCTGGCAGTT\n6:     6 GCTACGATAATCTATTTTCCGTACATAGGCTGGACAAATCGGTACTCGCTGACTACTTGCTTACTATCCAGGCATCCAACATGGAATCGATTAATAGAGA"
  },
  {
    "objectID": "tema2.html#importar-y-exportar-datos-de-archivos",
    "href": "tema2.html#importar-y-exportar-datos-de-archivos",
    "title": "Importar y exportar datos",
    "section": "Importar y exportar datos de archivos",
    "text": "Importar y exportar datos de archivos\nLas funciones para importar (fread) y exportar (fwrite) tienen las siguientes opciones principales:\n\nx: el objeto que queremos exportar.\nfile: ruta para escribir/leer el archivo.\nsep: el delimitador entre columnas.\n\nNota: La función tiene muchos argumentos que pueden ayudarte a personalizar el proceso de cargar datos en R.\n\nConjunto de datos\nEn esta y la siguiente sección vamos a trabajar una tabla de todos los especímenes de plantas que tiene registrados la plataforma GBIF (Global Biodiversity Information Facility) para México. Específicamente esta tabla solo contiene los registros de plantas que tienen un especímen guardado en alguna colección biológica y que tienen coordenadas que nos permitan ubicarlos.\nEjemplo: Por ejemplo, podemos importar la tabla original de plantae_mexico_conCoords_specimen.csv que tiene 3062756 registros y 50 filas.\nLink para descargar la tabla completa. Descargarás una carpeta zip en donde viene el archivo de ocurrencias en formato Darwin Core (separado por comas)\nNota: fread() también permite leer archivos comprimidos .gz\nlibrary(data.table)\n\ndata = fread(\"data/plantae_mexico_conCoords_specimen.csv\", quote=\"\")\n\nhead(data) |&gt; knitr::kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngbifID\noccurrenceID\nphylum\nclass\norder\nfamily\ngenus\nspecies\ninfraspecificEpithet\ntaxonRank\nscientificName\nverbatimScientificName\nverbatimScientificNameAuthorship\ncountryCode\nstateProvince\ndecimalLatitude\ndecimalLongitude\ncoordinateUncertaintyInMeters\nelevation\nday\nmonth\nyear\nbasisOfRecord\n\n\n\n\n2825623524\nTAIF:PLANT:318128:1:1:411555\nTracheophyta\nPolypodiopsida\nPolypodiales\nPteridaceae\nAdiantum\nAdiantum andicola\n\nSPECIES\nAdiantum andicola Liebm.\nAdiantum andicola Liebm.\nNA\nMX\nOaxaca (瓦哈卡州)\n17.30213\n-96.38080\nNA\n2267\n27\n2\n2012\nPRESERVED_SPECIMEN\n\n\n2825649445\nTAIF:PLANT:318579:1:1:411579\nTracheophyta\nPolypodiopsida\nPolypodiales\nPteridaceae\nScoliosorus\nScoliosorus ensiformis\n\nSPECIES\nScoliosorus ensiformis (Hook.) T.Moore\nScoliosorus ensiformis (Hook.) T. Moore\nNA\nMX\nOaxaca (瓦哈卡州)\n17.30213\n-96.38080\nNA\n2267\n27\n2\n2012\nPRESERVED_SPECIMEN\n\n\n2825649446\nTAIF:PLANT:318694:1:1:411603\nTracheophyta\nPolypodiopsida\nPolypodiales\nPolypodiaceae\nPleopeltis\nPleopeltis polylepis\ninterjecta\nVARIETY\nPleopeltis polylepis var. interjecta (Weath.) E.A.Hooper\nPleopeltis polylepis (Roem. ex Kunze) T. Moore var. interjecta (Weath.) E. A. Hooper\nNA\nMX\nOaxaca (瓦哈卡州)\n17.38178\n-96.44162\nNA\n2959\n29\n2\n2012\nPRESERVED_SPECIMEN\n\n\n2825649447\nTAIF:PLANT:318705:1:1:411602\nTracheophyta\nPolypodiopsida\nPolypodiales\nAspleniaceae\nAsplenium\nAsplenium monanthes\n\nSPECIES\nAsplenium monanthes L.\nAsplenium monanthes L.\nNA\nMX\nOaxaca (瓦哈卡州)\n17.36213\n-96.44678\nNA\n2820\n29\n2\n2012\nPRESERVED_SPECIMEN\n\n\n2825649448\nTAIF:PLANT:318740:1:1:411609\nTracheophyta\nLycopodiopsida\nLycopodiales\nLycopodiaceae\nDiphasiastrum\nDiphasiastrum thyoides\n\nSPECIES\nDiphasiastrum thyoides (Humb. & Bonpl. ex Willd.) Holub\nDiphasiastrum thyoides (Humb. & Bonpl. ex Willd.) Holub\nNA\nMX\nOaxaca (瓦哈卡州)\n17.30213\n-96.38080\nNA\n2267\n27\n2\n2012\nPRESERVED_SPECIMEN\n\n\n2825649449\nTAIF:PLANT:318741:1:1:411583\nTracheophyta\nPolypodiopsida\nEquisetales\nEquisetaceae\nEquisetum\nEquisetum praealtum\naffine\nVARIETY\nEquisetum hyemale var. affine (Engelm.) A.A.Eaton\nEquisetum hyemale L. var. affine (Engelm.) A. A. Eaton\nNA\nMX\nOaxaca (瓦哈卡州)\n17.35835\n-96.44460\nNA\n2000\n1\n3\n2012\nPRESERVED_SPECIMEN\n\n\n\n\n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\nUtiliza el código anterior para cargar la tabla de especímenes en tu computadora.\nNota: La tabla tiene más de 3 millones de registros y, en las pruebas que hicimos, observamos que la tabla ocupa 1.72 GB de memoria cuando se carga. Incluimos un subconjunto aleatorio de 100,000 filas (sub_100000_plantae_mexico_conCoords_specimen.csv) para los que quieran practicar con objetos que ocupen menos memoria."
  },
  {
    "objectID": "tema2.html#exportar",
    "href": "tema2.html#exportar",
    "title": "Importar y exportar datos",
    "section": "Exportar",
    "text": "Exportar\ndata.table también tiene una función optimizada para escribir los datos con los que estamos trabajando en forma de archivo. Los argumentos básicos son:\n\nx = objeto que se quiere exportar como archivo\nfile = nombre del archivo\nsep = caracter que se quiere utilizar como delimitador de campo\ncompress = debido a que podríamos estar trabajando con tablas de datos muy grandes podemos escribir los archivos comprimidos. Se puede especificar “gzip” o “auto” y utilizar la extension .gz en el nombre del archivo para escribir un archivo comprimido, la opción “none” nos permite escribir archivos sin comprimir.\n\nEjemplo: podemos escribir la tabla DT que creamos al principio de la sección:\nfwrite(DT, \"data/testDT.csv\", sep = \",\")\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\n\nExporta la tabla de registros de especimenes como un archivo comprimido.\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\nfwrite(data, \"data/sub_100000_plantae_mexico_conCoords_specimen.csv.gz\", sep = \",\", compress = \"auto\")"
  },
  {
    "objectID": "tema2.html#velocidad-dplyr-vs-data.table",
    "href": "tema2.html#velocidad-dplyr-vs-data.table",
    "title": "Importar y exportar datos",
    "section": "Velocidad dplyr vs data.table",
    "text": "Velocidad dplyr vs data.table\n\nlibrary(rbenchmark)\n\ntest = benchmark(\"r base\" = {\n            read.csv(\"big_data/plantae_mexico_conCoords_specimen.csv\")\n          },\n          \"data.table\" = {\n            fread(\"big_data/plantae_mexico_conCoords_specimen.csv\")\n          },\n          replications = 10,\n          columns = c(\"test\", \"replications\", \"elapsed\",\n                      \"relative\", \"user.self\", \"sys.self\"))\nNota: Si quieres correr este código revisa cuántas réplicas quieres hacer porque está escrito para leer la tabla de registros grande 10 veces utilizando cada método.\n\n\n\n\n\nX\ntest\nreplications\nelapsed\nrelative\nuser.self\nsys.self\n\n\n\n\n2\ndata.table\n10\n110.933\n1.000\n206.818\n3.027\n\n\n1\nr base\n10\n380.665\n3.431\n376.605\n4.057\n\n\n\n\n\n\n\n\n\n\n\nReto\n\n\n\n\n\nSi quieres, puedes revisar el tiempo que te toma cargar la base de datos XX utilizando read.csv y fread. Utiliza el comando de benchmark de la paquetería rbenchmark para contar el tiempo. Nota: en el número de réplicas puedes poner una o dos porque si no te vas a tardar mucho."
  },
  {
    "objectID": "tema2.html#data.frame---data.table",
    "href": "tema2.html#data.frame---data.table",
    "title": "Importar y exportar datos",
    "section": "data.frame - data.table",
    "text": "data.frame - data.table\nEl objeto de data.table es un objeto basado en un data.frame, por lo tanto es compatible con las funciones de R base que trabajan con data.frame.\nstr(data)\nClasses ‘data.table’ and 'data.frame':  3062756 obs. of  23 variables:\n $ gbifID                          :integer64 2825623524 2825649445 2825649446 2825649447 2825649448 2825649449 2825649452 2825649453 ... \n $ occurrenceID                    : chr  \"TAIF:PLANT:318128:1:1:411555\" \"TAIF:PLANT:318579:1:1:411579\" \"TAIF:PLANT:318694:1:1:411603\" \"TAIF:PLANT:318705:1:1:411602\" ...\n $ phylum                          : chr  \"Tracheophyta\" \"Tracheophyta\" \"Tracheophyta\" \"Tracheophyta\" ...\n $ class                           : chr  \"Polypodiopsida\" \"Polypodiopsida\" \"Polypodiopsida\" \"Polypodiopsida\" ...\n $ order                           : chr  \"Polypodiales\" \"Polypodiales\" \"Polypodiales\" \"Polypodiales\" ...\n $ family                          : chr  \"Pteridaceae\" \"Pteridaceae\" \"Polypodiaceae\" \"Aspleniaceae\" ...\n $ genus                           : chr  \"Adiantum\" \"Scoliosorus\" \"Pleopeltis\" \"Asplenium\" ...\n $ species                         : chr  \"Adiantum andicola\" \"Scoliosorus ensiformis\" \"Pleopeltis polylepis\" \"Asplenium monanthes\" ...\n $ infraspecificEpithet            : chr  \"\" \"\" \"interjecta\" \"\" ...\n $ taxonRank                       : chr  \"SPECIES\" \"SPECIES\" \"VARIETY\" \"SPECIES\" ...\n $ scientificName                  : chr  \"Adiantum andicola Liebm.\" \"Scoliosorus ensiformis (Hook.) T.Moore\" \"Pleopeltis polylepis var. interjecta (Weath.) E.A.Hooper\" \"Asplenium monanthes L.\" ...\n $ verbatimScientificName          : chr  \"Adiantum andicola Liebm.\" \"Scoliosorus ensiformis (Hook.) T. Moore\" \"Pleopeltis polylepis (Roem. ex Kunze) T. Moore var. interjecta (Weath.) E. A. Hooper\" \"Asplenium monanthes L.\" ...\n $ verbatimScientificNameAuthorship: chr  \"\" \"\" \"\" \"\" ...\n $ countryCode                     : chr  \"MX\" \"MX\" \"MX\" \"MX\" ...\n $ stateProvince                   : chr  \"Oaxaca (瓦哈卡州)\" \"Oaxaca (瓦哈卡州)\" \"Oaxaca (瓦哈卡州)\" \"Oaxaca (瓦哈卡州)\" ...\n $ decimalLatitude                 : num  17.3 17.3 17.4 17.4 17.3 ...\n $ decimalLongitude                : num  -96.4 -96.4 -96.4 -96.4 -96.4 ...\n $ coordinateUncertaintyInMeters   : num  NA NA NA NA NA NA NA NA NA NA ...\n $ elevation                       : num  2267 2267 2959 2820 2267 ...\n $ day                             : int  27 27 29 29 27 1 27 27 5 1 ...\n $ month                           : int  2 2 2 2 2 3 2 2 5 3 ...\n $ year                            : int  2012 2012 2012 2012 2012 2012 2012 2012 2000 2012 ...\n $ basisOfRecord                   : chr  \"PRESERVED_SPECIMEN\" \"PRESERVED_SPECIMEN\" \"PRESERVED_SPECIMEN\" \"PRESERVED_SPECIMEN\" ...\n - attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n - attr(*, \"index\")= int(0) \n  ..- attr(*, \"__genus\")= int [1:3062756] 419 423 490 494 513 514 521 542 571 585 ...\n\nSin embargo, los objetos se pueden cambiar de clase. Por ejemplo:\n\nlibrary(magrittr)\n\nas.data.frame(DT) %&gt;% class()\n\n[1] \"data.frame\"\n\nas.data.frame(DT) %&gt;% as.data.table() %&gt;% class()\n\n[1] \"data.table\" \"data.frame\""
  },
  {
    "objectID": "tema6.html",
    "href": "tema6.html",
    "title": "Cadenas de operaciones",
    "section": "",
    "text": "Una función muy importante del paquete es la capacidad de encadenar operaciones en un mismo comando sin necesidad de guardar el resultado en algun objeto.\nEs una función similar al uso del pipe %&gt;% o |&gt; en tidyverse o rbase. En data table se pueden evaluar una serie de expresiones una después de la otra escribiendolas entre corchetes de esta manera:\nDT[ ... ][ ... ][ ... ]\no de forma vertical\nDT[ ...\n   ][ ...\n     ][ ...\n       ]\nPor ejemplo, recapitulando temas anteriores, utilizando la tabla de registros de plantas de México podemos:\n\nSeleccionar los registros del género Quercus y filtrar aquellos que no tienen información acerca de la especie o del año de colecta\n\n\nlibrary(data.table)\n\ndata = fread(\"data/plantae_mexico_conCoords_specimen.csv\")\n\ndata[genus == \"Quercus\" & !is.na(species) & species != \"\" & !is.na(year)]\n\nAgrupar por especie y por año de colecta\nContar el número de registros de que se realizó para cada especie en cada año\n\n\ndata[genus == \"Quercus\" & !is.na(species) & species != \"\" & !is.na(year), .(.N), by = .(year,species)]\n\nOrdenar la columna de número de registros de mayor a menor utilizando una cadena de operaciones\n\n\ndata[genus == \"Quercus\" & !is.na(species) & species != \"\" & !is.na(year), .(N = .N), by = .(year,species)][order(year,-N)]\n\n\n       year                   species     N\n      &lt;int&gt;                    &lt;char&gt; &lt;int&gt;\n   1:  1827 Quercus toxicodendrifolia     5\n   2:  1827           Quercus repanda     1\n   3:  1827         Quercus caudicans     1\n   4:  1828          Quercus cortesii     1\n   5:  1829        Quercus lancifolia     1\n  ---                                      \n6041:  2023     Quercus hypoleucoides     1\n6042:  2023      Quercus oblongifolia     1\n6043:  2023           Quercus toumeyi     1\n6044:  2023           Quercus viminea     1\n6045:  2023         Quercus arizonica     1"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "tema1.html",
    "href": "tema1.html",
    "title": "Sintaxis básica",
    "section": "",
    "text": "data.table es un objeto de R que está pensado para mantener las operaciones en uno o pocos comandos. La lógica de la sintaxis básica es la siguiente:"
  },
  {
    "objectID": "tema1.html#cheatsheet",
    "href": "tema1.html#cheatsheet",
    "title": "Sintaxis básica",
    "section": "Cheatsheet",
    "text": "Cheatsheet"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción y recursos",
    "section": "",
    "text": "Es un paquete que extiende y hace más eficiente el data.frame de R base. De acuerdo con los creadores del paquete:\n\nLas operaciones de manipulación de datos como subconjunto, grupo, actualización, unión, etc., están inherentemente relacionadas. Mantener estas operaciones juntas permite:\n\n\n\nuna sintaxis concisa y consistente independientemente del conjunto de operaciones que desees realizar para lograr tu objetivo final.\nrealizar análisis de manera fluida sin la carga cognitiva de tener que mapear cada operación a una función particular de un conjunto potencialmente enorme de funciones disponibles antes de realizar el análisis.\noptimizar automáticamente las operaciones internamente y de manera muy efectiva, al saber precisamente los datos requeridos para cada operación, lo que lleva a un código muy rápido y eficiente en términos de memoria.\n\n\n\nEn resumen, si estás interesado en reducir enormemente el tiempo de programación y computación, entonces este paquete es para ti.\n\n\n(Vigñeta de introducción a data.table)"
  },
  {
    "objectID": "index.html#qué-es-qué-ventajas-tiene",
    "href": "index.html#qué-es-qué-ventajas-tiene",
    "title": "Introducción y recursos",
    "section": "",
    "text": "Es un paquete que extiende y hace más eficiente el data.frame de R base. De acuerdo con los creadores del paquete:\n\nLas operaciones de manipulación de datos como subconjunto, grupo, actualización, unión, etc., están inherentemente relacionadas. Mantener estas operaciones juntas permite:\n\n\n\nuna sintaxis concisa y consistente independientemente del conjunto de operaciones que desees realizar para lograr tu objetivo final.\nrealizar análisis de manera fluida sin la carga cognitiva de tener que mapear cada operación a una función particular de un conjunto potencialmente enorme de funciones disponibles antes de realizar el análisis.\noptimizar automáticamente las operaciones internamente y de manera muy efectiva, al saber precisamente los datos requeridos para cada operación, lo que lleva a un código muy rápido y eficiente en términos de memoria.\n\n\n\nEn resumen, si estás interesado en reducir enormemente el tiempo de programación y computación, entonces este paquete es para ti.\n\n\n(Vigñeta de introducción a data.table)"
  },
  {
    "objectID": "index.html#comparaciones-con-otros-paquetes",
    "href": "index.html#comparaciones-con-otros-paquetes",
    "title": "Introducción y recursos",
    "section": "Comparaciones con otros paquetes",
    "text": "Comparaciones con otros paquetes\nBenchmarks"
  },
  {
    "objectID": "tema4.html",
    "href": "tema4.html",
    "title": "Modificación de columnas",
    "section": "",
    "text": "Durante esta sección continuaremos trabajando con el datase de especímenes de plantas que tiene registrados la plataforma GBIF (Global Biodiversity Information Facility) para México. Pero para otros ejercicios usaremos un conjunto de datos que contiene información de la Oficina de Estadísticas de Transporte para todos los vuelos que partieron de los aeropuertos de la ciudad de Nueva York en 2014 (https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv)."
  },
  {
    "objectID": "tema4.html#selección-por-múltiples-filtros",
    "href": "tema4.html#selección-por-múltiples-filtros",
    "title": "Modificación de columnas",
    "section": "Selección por múltiples filtros",
    "text": "Selección por múltiples filtros\nAquí sólo mostraremos un ejemplo de algo que se retomará en el tema 6 Por ejemplo si nos interesa seleccionar los datos de acuerdo a más de una característica podemos apoyarnos del operador &.\n\nplants[family==\"Araceae\" & year==1997]\n\n       gbifID                     occurrenceID       phylum      class       order  family     genus\n        &lt;i64&gt;                           &lt;char&gt;       &lt;char&gt;     &lt;char&gt;      &lt;char&gt;  &lt;char&gt;    &lt;char&gt;\n1: 2629021831 6973d68ba4951b05f1b767cad9c7a3bd Tracheophyta Liliopsida Alismatales Araceae   Wolffia\n2: 3308025546 ada5d16106857bd7c0d8ee0bc8d90d92 Tracheophyta Liliopsida Alismatales Araceae Anthurium\n3: 2629020382 18de679e2ae5d3769b04a72485ec6277 Tracheophyta Liliopsida Alismatales Araceae     Lemna\n4: 1895542847 326fcc93e9a784983d7f0b40b457fb77 Tracheophyta Liliopsida Alismatales Araceae   Wolffia\n                species infraspecificEpithet taxonRank             scientificName verbatimScientificName\n                 &lt;char&gt;               &lt;char&gt;    &lt;char&gt;                     &lt;char&gt;                 &lt;char&gt;\n1: Wolffia brasiliensis                        SPECIES Wolffia brasiliensis Wedd.   Wolffia brasiliensis\n2:   Anthurium umbrosum                        SPECIES  Anthurium umbrosum Liebm.     Anthurium umbrosum\n3: Lemna aequinoctialis                        SPECIES Lemna aequinoctialis Welw.   Lemna aequinoctialis\n4: Wolffia brasiliensis                        SPECIES Wolffia brasiliensis Wedd.   Wolffia brasiliensis\n   verbatimScientificNameAuthorship countryCode stateProvince decimalLatitude decimalLongitude\n                             &lt;char&gt;      &lt;char&gt;        &lt;char&gt;           &lt;num&gt;            &lt;num&gt;\n1:                      Wedd., 1849          MX       Morelos        18.53389        -99.05700\n2:                     Liebm., 1850          MX        Oaxaca        17.49861        -96.35417\n3:                      Welw., 1859          MX       Morelos        18.62736        -99.41153\n4:                      Wedd., 1849          MX       Morelos        18.55678        -99.01744\n   coordinateUncertaintyInMeters elevation   day month  year      basisOfRecord\n                           &lt;num&gt;     &lt;num&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;             &lt;char&gt;\n1:                            90     485.0    10    10  1997 PRESERVED_SPECIMEN\n2:                            90    1790.0     8     6  1997 PRESERVED_SPECIMEN\n3:                            90     517.5    11    10  1997 PRESERVED_SPECIMEN\n4:                            90     587.5    26     9  1997 PRESERVED_SPECIMEN\n\n\n\n\nOperaciones en j\nPero además de aplicar filtros data.table nos permite efectuar operaciones por ejemplo contar cuántas coincidencias tenemos para nuestros criterios aplicados.\n\nplants[family==\"Araceae\" & year==1997, .N]\n\n[1] 4\n\n\nEs importante notar que en el primer espacio de nuestro corchete filtramos mientras en el segundo hicimos una operación. Lo que hicimos nos permite saber cuántas coincidencias hay de plantas registradas en 1997 independientemente de la especie. Existen símbolos especiales como .N que nos cuenta el número de observaciones que cumplen nuestros criterios.\n\n\n\n\n\n\nEjercicio\n\n\n\n\n\nPregunta: ¿Cuántos registros hay para el año 1983? (Utiliza .N)\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n\nplants[year==1983, .N]\n\n[1] 2769\n\n\n\n\n\nAdemás de esto podemos hacer operaciones, pero para esta parte usaremos otro dataset\n\nflights &lt;- fread(\"data/flights14.csv\")\n\nPor ejemplo si quisieramos saber el promedio de retraso de salida de los vuelos haríamos lo que sigue\n\nflights[, mean(dep_delay)]\n\n[1] 12.46526\n\n\nAhora calcularemos el promedio de retraso de salida para todo los vuelos que salieron del aeropuerto JFK en el mes de febrero.\n\nflights[origin == \"JFK\" & month == 2L,\n        .(mean_arr = mean(arr_delay))]\n\n   mean_arr\n      &lt;num&gt;\n1: 21.18646\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\n\nAhora es tu turno: Calcula el promedio de retraso de salida y entrada para todo los vuelos que salieron del aeropuerto JFK en el mes de Junio. Llama a tus nuevas columnas “mean_arr” y “mean_dep”\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n\nflights[origin == \"JFK\" & month == 6L,\n        .(mean_arr = mean(arr_delay), mean_dep = mean(dep_delay))]\n\n   mean_arr mean_dep\n      &lt;num&gt;    &lt;num&gt;\n1: 5.839349 9.807884"
  },
  {
    "objectID": "tema4.html#respuesta",
    "href": "tema4.html#respuesta",
    "title": "Modificación de columnas",
    "section": "Respuesta",
    "text": "Respuesta\n\nplants[year==1983, .N]\n\n[1] 2769\n\n\nAdemás de esto podemos hacer operaciones, pero para esta parte usaremos otro dataset\n\nflights &lt;- fread(\"data/flights14.csv\")\n\nPor ejemplo si quisieramos saber el promedio de retraso de salida de los vuelos haríamos lo que sigue\n\nflights[, mean(dep_delay)]\n\n[1] 12.46526\n\n\nAhora calcularemos el promedio de retraso de salida para todo los vuelos que salieron del aeropuerto JFK en el mes de febrero.\n\nflights[origin == \"JFK\" & month == 2L,\n        .(mean_arr = mean(arr_delay))]\n\n   mean_arr\n1: 21.18646\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\n\nAhora es tu turno: Calcula el promedio de retraso de salida y entrada para todo los vuelos que salieron del aeropuerto JFK en el mes de Junio. Llama a tus nuevas columnas “mean_arr” y “mean_dep”\n\n\n\n::: {.callout-note collapse=“true”}\n\nflights[origin == \"JFK\" & month == 6L,\n        .(mean_arr = mean(arr_delay), mean_dep = mean(dep_delay))]\n\n   mean_arr mean_dep\n1: 5.839349 9.807884"
  },
  {
    "objectID": "tema4.html#agregar-nuevas-columnas-a-nuestro-data.table",
    "href": "tema4.html#agregar-nuevas-columnas-a-nuestro-data.table",
    "title": "Modificación de columnas",
    "section": "Agregar nuevas columnas a nuestro data.table",
    "text": "Agregar nuevas columnas a nuestro data.table\nAhora qué sucede si queremos generar una nueva columna dentro de nuestro data frame. Por ejemplo si estimamos la diferencia que hay entre los retrasos de salida y llegada\n\nflights[, dif:=dep_delay - arr_delay]\nflights\n\nIndex: &lt;month__origin&gt;\n         year month   day dep_delay arr_delay carrier origin   dest air_time distance  hour   dif\n        &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;     &lt;int&gt;  &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;\n     1:  2014     1     1        14        13      AA    JFK    LAX      359     2475     9     1\n     2:  2014     1     1        -3        13      AA    JFK    LAX      363     2475    11   -16\n     3:  2014     1     1         2         9      AA    JFK    LAX      351     2475    19    -7\n     4:  2014     1     1        -8       -26      AA    LGA    PBI      157     1035     7    18\n     5:  2014     1     1         2         1      AA    JFK    LAX      350     2475    13     1\n    ---                                                                                          \n253312:  2014    10    31         1       -30      UA    LGA    IAH      201     1416    14    31\n253313:  2014    10    31        -5       -14      UA    EWR    IAH      189     1400     8     9\n253314:  2014    10    31        -8        16      MQ    LGA    RDU       83      431    11   -24\n253315:  2014    10    31        -4        15      MQ    LGA    DTW       75      502    11   -19\n253316:  2014    10    31        -5         1      MQ    LGA    SDF      110      659     8    -6\n\n\nSino quisiera agregarla esto es lo que se haría\n\nflights[, .(dif = dep_delay - arr_delay)]\n\n          dif\n        &lt;int&gt;\n     1:     1\n     2:   -16\n     3:    -7\n     4:    18\n     5:     1\n    ---      \n253312:    31\n253313:     9\n253314:   -24\n253315:   -19\n253316:    -6"
  },
  {
    "objectID": "tema5.html",
    "href": "tema5.html",
    "title": "Agrupación",
    "section": "",
    "text": "Ahora continuaremos usando el dataset de las plantas para sacar datos considerando agrupaciones. Por ejemplo podemos estimar cuántos registros hubo por año?\n\nplants[, .N,  by = year]\n\n      year     N\n     &lt;int&gt; &lt;int&gt;\n  1:  1983  2769\n  2:  1998  2525\n  3:  1990  2366\n  4:  2003  1608\n  5:  1970  1003\n ---            \n190:  1846     2\n191:  1832     1\n192:  1852     1\n193:  1873     1\n194:  1788     1\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\n\nPodrías identificar en qué año se tienen más registros? No es necesario usar la nomeclatura de data.table.\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n\ntmp_plants &lt;- plants[, .N,  by = year]\ntmp_plants[order(-N)][1]\n\n    year     N\n   &lt;int&gt; &lt;int&gt;\n1:  1986  3333\n\n\n\n\n\nComo viste podemos usar la nomeclatura secuencialmente, pero esto sólo es un spoiler de los temas que verás a continuación.\n\nPodemos también buscar el año más antiguo del que tenemos registro por familia\n\nplants[, min(year),by=family]\n\n            family    V1\n            &lt;char&gt; &lt;int&gt;\n  1:       Araceae    NA\n  2:  Goodeniaceae  1919\n  3:  Bromeliaceae    NA\n  4: Commelinaceae    NA\n  5:    Asteraceae    NA\n ---                    \n493:   Ulvellaceae    NA\n494:    Timmiaceae  1985\n495:   Onocleaceae  1983\n496: Lepicoleaceae  1973\n497: Sarcobataceae  1972\n\n\nPodemos usar by con mutiples factores? Por ejemplo saber cuántos registros tenemos por año para cada familia\n\nplants[, .N,by=.(family, year)]\n\n               family  year     N\n               &lt;char&gt; &lt;int&gt; &lt;int&gt;\n    1:        Araceae  1983    10\n    2:   Goodeniaceae  1998     2\n    3:   Bromeliaceae  1990    25\n    4:  Commelinaceae  2003    16\n    5:     Asteraceae  1970   145\n   ---                           \n14218: Gleicheniaceae  1986     1\n14219:   Gentianaceae  2014     1\n14220:  Hernandiaceae  2000     1\n14221:       Fabaceae  1841     1\n14222:   Polygalaceae  2014     1\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\n\nEn qué año y para qué familia hay más registros?\n\n\n\n\n\n\n\n\n\nRespuesta\n\n\n\n\n\n\ntemp_plants2 &lt;- plants[, .N,by=.(family, year)]\ntemp_plants2[order(-N)][1]\n\n       family  year     N\n       &lt;char&gt; &lt;int&gt; &lt;int&gt;\n1: Asteraceae  1986   483"
  }
]